<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# splay

```go
import "github.com/zyedidia/generic/splay"
```

Package splay provides an implementation of a Splay tree\. A splay tree is a self\-balancing binary search tree with amortized O\(log N\) complexity on all operations\. Especially\, it supports range\-based aggregation and updation in a simply way\. It also has a good performance when data accessing has a pattern that the same key is accessed frequently in a short time\. Generally\, its performance againse random operation is not as good as a well\-tuned red\-black tree or AVL tree\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	g "github.com/zyedidia/generic"
	agg "github.com/zyedidia/generic/aggregator"
	"github.com/zyedidia/generic/splay"
)

func main() {
	tree := splay.New(g.Less[int], agg.NewMinMaxAggregator(g.Less[string]))

	tree.Put(42, "foo")
	tree.Put(-10, "bar")
	tree.Put(0, "baz")
	tree.Put(10, "quux")
	tree.Remove(10)

	tree.Each(func(key int, val string) {
		fmt.Println(key, val)
	})

	fmt.Println(tree.Range(-10, 10).Min())

}
```

#### Output

```
-10 bar
0 baz
42 foo
bar
```

</p>
</details>

## Index

- [type Tree](<#type-tree>)
  - [func New[K, V, A, R any](less g.LessFn[K], aggregator agg.Aggregator[V, A, R]) *Tree[K, V, A, R]](<#func-new>)
  - [func (t *Tree[K, V, A, R]) Each(fn func(K, V))](<#func-treek-v-a-r-each>)
  - [func (t *Tree[K, V, A, R]) Get(key K) (V, bool)](<#func-treek-v-a-r-get>)
  - [func (t *Tree[K, V, A, R]) Put(key K, value V)](<#func-treek-v-a-r-put>)
  - [func (t *Tree[K, V, A, R]) Range(l, r K) R](<#func-treek-v-a-r-range>)
  - [func (t *Tree[K, V, A, R]) Remove(key K)](<#func-treek-v-a-r-remove>)
  - [func (t *Tree[K, V, A, R]) Size() int](<#func-treek-v-a-r-size>)


## type [Tree](<https://github.com/zjkmxy/generic/blob/master/splay/splay.go#L24-L39>)

Tree implements a Splay tree\.

```go
type Tree[K, V, A, R any] struct {
    // contains filtered or unexported fields
}
```

### func [New](<https://github.com/zjkmxy/generic/blob/master/splay/splay.go#L246>)

```go
func New[K, V, A, R any](less g.LessFn[K], aggregator agg.Aggregator[V, A, R]) *Tree[K, V, A, R]
```

New returns an empty Splay tree\.

### func \(\*Tree\[K\, V\, A\, R\]\) [Each](<https://github.com/zjkmxy/generic/blob/master/splay/splay.go#L238>)

```go
func (t *Tree[K, V, A, R]) Each(fn func(K, V))
```

Each calls 'fn' on every node in the tree in order

### func \(\*Tree\[K\, V\, A\, R\]\) [Get](<https://github.com/zjkmxy/generic/blob/master/splay/splay.go#L184>)

```go
func (t *Tree[K, V, A, R]) Get(key K) (V, bool)
```

Get returns the value associated with 'key'\.

### func \(\*Tree\[K\, V\, A\, R\]\) [Put](<https://github.com/zjkmxy/generic/blob/master/splay/splay.go#L194>)

```go
func (t *Tree[K, V, A, R]) Put(key K, value V)
```

Put associates 'key' with 'value'\.

### func \(\*Tree\[K\, V\, A\, R\]\) [Range](<https://github.com/zjkmxy/generic/blob/master/splay/splay.go#L263>)

```go
func (t *Tree[K, V, A, R]) Range(l, r K) R
```

Range returns the aggregator associated with key range \[l\, r\)\, which can be used to obtain statistics or do range\-based update\. Note that the range is only valid before next operation on the tree\.

### func \(\*Tree\[K\, V\, A\, R\]\) [Remove](<https://github.com/zjkmxy/generic/blob/master/splay/splay.go#L216>)

```go
func (t *Tree[K, V, A, R]) Remove(key K)
```

Remove removes the value associated with 'key'\.

### func \(\*Tree\[K\, V\, A\, R\]\) [Size](<https://github.com/zjkmxy/generic/blob/master/splay/splay.go#L233>)

```go
func (t *Tree[K, V, A, R]) Size() int
```

Size returns the number of elements in the tree\.



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
